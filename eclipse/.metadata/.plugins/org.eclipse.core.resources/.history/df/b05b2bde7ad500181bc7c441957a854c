package net.theexceptionist.coherentvillages.main.entity;

import java.util.Random;

import javax.annotation.Nullable;

import com.google.common.base.Predicate;

import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.ai.EntityAIBase;
import net.minecraft.entity.ai.EntityAIHurtByTarget;
import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
import net.minecraft.entity.ai.EntityMoveHelper;
import net.minecraft.entity.monster.EntityGhast;
import net.minecraft.entity.monster.EntityGolem;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.monster.IMob;
import net.minecraft.entity.passive.EntityTameable;
import net.minecraft.entity.passive.EntityVillager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;

public class EntityWraith extends EntityMob implements IMob{

	public EntityWraith(World worldIn) {
		super(worldIn);
		this.moveHelper = new EntityWraith.GhastMoveHelper(this);
	}
	
	protected void initEntityAI()
    {
		this.tasks.addTask(5, new EntityWraith.AIRandomFly(this));
        this.tasks.addTask(7, new EntityWraith.AILookAround(this));
        
	    this.targetTasks.addTask(6, new EntityAINearestAttackableTarget(this, EntityPlayer.class, true));
	    this.targetTasks.addTask(2, new EntityAINearestAttackableTarget(this, EntityVillager.class, true));
	    this.targetTasks.addTask(3, new EntityAINearestAttackableTarget(this, EntityGolem.class, true));
	    
	    this.targetTasks.addTask(0, new EntityAINearestAttackableTarget(this, EntityLiving.class, 1, true, true, new Predicate<EntityLiving>()
	    {
	       public boolean apply(@Nullable EntityLiving p_apply_1_)
	            {
	            	return p_apply_1_ != null && !(p_apply_1_ instanceof EntityTameable) && !(p_apply_1_ instanceof IMob);// /*|| (p_apply_1_ instanceof IAnimal)*/);
	            }
	    }));
	    this.targetTasks.addTask(1, new EntityAIHurtByTarget(this, false, new Class[0]));
    }
	
	 static class AILookAround extends EntityAIBase
     {
         private final EntityWraith parentEntity;

         public AILookAround(EntityWraith ghast)
         {
             this.parentEntity = ghast;
             this.setMutexBits(2);
         }

         /**
          * Returns whether the EntityAIBase should begin execution.
          */
         public boolean shouldExecute()
         {
             return true;
         }

         /**
          * Keep ticking a continuous task that has already been started
          */
         public void updateTask()
         {
             if (this.parentEntity.getAttackTarget() == null)
             {
                 this.parentEntity.rotationYaw = -((float)MathHelper.atan2(this.parentEntity.motionX, this.parentEntity.motionZ)) * (180F / (float)Math.PI);
                 this.parentEntity.renderYawOffset = this.parentEntity.rotationYaw;
             }
             else
             {
                 EntityLivingBase entitylivingbase = this.parentEntity.getAttackTarget();
                 double d0 = 64.0D;

                 if (entitylivingbase.getDistanceSq(this.parentEntity) < 4096.0D)
                 {
                     double d1 = entitylivingbase.posX - this.parentEntity.posX;
                     double d2 = entitylivingbase.posZ - this.parentEntity.posZ;
                     this.parentEntity.rotationYaw = -((float)MathHelper.atan2(d1, d2)) * (180F / (float)Math.PI);
                     this.parentEntity.renderYawOffset = this.parentEntity.rotationYaw;
                 }
             }
         }
     }

 static class AIRandomFly extends EntityAIBase
     {
         private final EntityWraith parentEntity;

         public AIRandomFly(EntityWraith ghast)
         {
             this.parentEntity = ghast;
             this.setMutexBits(1);
         }

         /**
          * Returns whether the EntityAIBase should begin execution.
          */
         public boolean shouldExecute()
         {
             EntityMoveHelper entitymovehelper = this.parentEntity.getMoveHelper();

             if (!entitymovehelper.isUpdating())
             {
                 return true;
             }
             else
             {
                 double d0 = entitymovehelper.getX() - this.parentEntity.posX;
                 double d1 = entitymovehelper.getY() - this.parentEntity.posY;
                 double d2 = entitymovehelper.getZ() - this.parentEntity.posZ;
                 double d3 = d0 * d0 + d1 * d1 + d2 * d2;
                 return d3 < 1.0D || d3 > 3600.0D;
             }
         }

         /**
          * Returns whether an in-progress EntityAIBase should continue executing
          */
         public boolean shouldContinueExecuting()
         {
             return false;
         }

         /**
          * Execute a one shot task or start executing a continuous task
          */
         public void startExecuting()
         {
             Random random = this.parentEntity.getRNG();
             double d0 = this.parentEntity.posX + (double)((random.nextFloat() * 2.0F - 1.0F) * 16.0F);
             double d1 = this.parentEntity.posY + (double)((random.nextFloat() * 2.0F - 1.0F) * 16.0F);
             double d2 = this.parentEntity.posZ + (double)((random.nextFloat() * 2.0F - 1.0F) * 16.0F);
             this.parentEntity.getMoveHelper().setMoveTo(d0, d1, d2, 1.0D);
         }
     }

 static class GhastMoveHelper extends EntityMoveHelper
     {
         private final EntityWraith parentEntity;
         private int courseChangeCooldown;

         public GhastMoveHelper(EntityWraith ghast)
         {
             super(ghast);
             this.parentEntity = ghast;
         }

         public void onUpdateMoveHelper()
         {
             if (this.action == EntityMoveHelper.Action.MOVE_TO)
             {
                 double d0 = this.posX - this.parentEntity.posX;
                 double d1 = this.posY - this.parentEntity.posY;
                 double d2 = this.posZ - this.parentEntity.posZ;
                 double d3 = d0 * d0 + d1 * d1 + d2 * d2;

                 if (this.courseChangeCooldown-- <= 0)
                 {
                     this.courseChangeCooldown += this.parentEntity.getRNG().nextInt(5) + 2;
                     d3 = (double)MathHelper.sqrt(d3);

                     if (this.isNotColliding(this.posX, this.posY, this.posZ, d3))
                     {
                         this.parentEntity.motionX += d0 / d3 * 0.1D;
                         this.parentEntity.motionY += d1 / d3 * 0.1D;
                         this.parentEntity.motionZ += d2 / d3 * 0.1D;
                     }
                     else
                     {
                         this.action = EntityMoveHelper.Action.WAIT;
                     }
                 }
             }
         }

         /**
          * Checks if entity bounding box is not colliding with terrain
          */
         private boolean isNotColliding(double x, double y, double z, double p_179926_7_)
         {
             double d0 = (x - this.parentEntity.posX) / p_179926_7_;
             double d1 = (y - this.parentEntity.posY) / p_179926_7_;
             double d2 = (z - this.parentEntity.posZ) / p_179926_7_;
             AxisAlignedBB axisalignedbb = this.parentEntity.getEntityBoundingBox();

             for (int i = 1; (double)i < p_179926_7_; ++i)
             {
                 axisalignedbb = axisalignedbb.offset(d0, d1, d2);

                 if (!this.parentEntity.world.getCollisionBoxes(this.parentEntity, axisalignedbb).isEmpty())
                 {
                     return false;
                 }
             }

             return true;
         }
     }

}
